# goqty

Goqty is a Go port of gentooboontoo's js-quantities Javascript library (https://github.com/gentooboontoo/js-quantities) which is a port of Kevin Olbrich's Ruby library
Units (https://github.com/olbrich/ruby-units).

The library aims to simplify the handling of units for scientific calculations involving quantities.

This library has no dependencies.

## Installation

go get github.com/wjanssens/goqty

## Usage

[source,go]
----
import (
    "fmt"
    "github.com/wjanssens/goqty"
)
if q, err := goqty.ParseQty("50km/h"); err == nil {
    fmt.Printf("%v\n", q) // => 50 km/h
}
----

## Synopsis

.Creation
[source,go]
----
qty, err = ParseQty("1m");
qty, err = ParseQty('m'); // scalar defaults to 1

// compound numerators
qty, err = ParseQty("1 N*m");
qty, err = ParseQty("1 N m"); // * is optional

// denominators
qty, err = ParseQty("1 m/s");

// powers
qty, err = ParseQty("1 m^2/s**2"); // ^ or **
qty, err = ParseQty("1 m^2 s^-2"); // negative powers
qty, err = ParseQty("1 m2 s-2"); // ^ is optional

qty, err = ParseQty("1 m^2 kg^2 J^2/s^2 A");

// unitless quantities
qty, err = ParseQty("1.5");
qty, err = NewQty(1.5, "");

// unicode prefixes and units
qty, err = ParseQty("1.5 µm");
qty, err = ParseQty("1.5 Ω");

qty = Qty("1 attoparsec/microfortnight");
----

.Properties
[source,go]
----
c := a.Scalar()         // returns the scalar of a quantity (10 m => 10)
u := a.Units()          // returns the units of a quantity (10 m => m)
k := a.Kind()           // returns the kind of a quantity (10 m => length)
----

.Predicates
[source,go]
----
t := a.IsInverse(b)     // true if quantities are the inverse of each other
t := a.IsCompatible(b)  // true if quantities have the same kind
t := a.IsUnitless()     // true if quantity has no units
t := a.IsBase()         // true if quantity is represented with base units
----

.Conversion
[source,go]
----
c, err := a.To('m')      // returns a scaled quantity (0.1 m => 10 cm)
c, err := a.To('S')      // returns an inverted quantity (10 ohm => .1 S)
c, err := a.ToBase()     // returns a quantity in SI units (10 cm => 0.1 m)
c, err := a.ToFloat()    // returns the scalar of a unitless quantity
c, err := a.Inverse()    // returns an interned quantity (100 m/s => .01 s/m; 10 ohm => .1 /ohm, not .1 S)
----

.Comparison
[source,go]
----
// quantities with compatible quantities can be compared
eq, err := a.Eq(b)          // true if both quantities are equal (1m == 100cm => true)
same, err := a.Same(b)      // true if both quantities are same (1m == 100cm => false)
lt, err := a.Lt(b)          // true if a is stricty less than b
lte, err := a.Lte(b)        // true if a is less than or equal to b
gt, err := a.Gt(b)          // true if a is stricty greater than b
gte, err := a.Gte(b)        // true if a is greater than or equal to b
v, err := a.compareTo(b);   // -1 if a < b, 0 if a == b, 1 if a > b
----

.Operators
[source,go]
----
// quantities with compatible quantities can be added and substracted
c, err := a.Add(b)          // 2.5 m + 3 cm => 2.53 m ; 3 cm + 2.5 m => 253 cm
c, err := a.Sub(b)          // 2.5 m - 3 cm => 2.47 m ; 3 cm - 2.5 m => -247 cm
// any quantities can be multiplied and divided (excluding temperatures)
c, err := a.Mul(b)          // 2.5 m * 3 cm => 0.075 m^2 ; 3 cm * 2.5 m => 750 cm^2
c, err := a.Div(b)          // 7.5 degF / 2.5 m^2 => 3 degF/m^2
----

.Rounding
[source,go]
----
q, _ := qty.Parse("5.17 ft")
q.ToPrec("ft");             // => 5 ft
q.ToPrec("0.5 ft");         // => 5 ft
q.ToPrec("0.25 ft");        // => 5.25 ft
q.ToPrec("0.1 ft");         // => 5.2 ft
q.ToPrec("0.05 ft");        // => 5.15 ft
q.ToPrec("0.01 ft");        // => 5.17 ft
q.ToPrec("0.00001 ft");     // => 5.17 ft
q.ToPrec("2 ft");           // => 6 ft
q.ToPrec("2");              // => 6 ft

q, _ = qty.Parse("6.3782 m");
q.ToPrec("dm");             // => 6.4 m
q.ToPrec("cm");             // => 6.38 m
q.ToPrec("mm");             // => 6.378 m
q.ToPrec("5 cm");           // => 6.4 m
q.ToPrec("10 m");           // => 10 m
qty.ToPrec(0.1);            // => 6.3 m

q, _ = qty.Parse("1.146 MPa");
q.ToPrec("0.1 bar");        // => 1.15 MPa
----

.Formatting
[source,go]
----
// String() can be used to get the cannonical representation of the quantity, which can always be parsed
q.String()                     // 1.146 MPa => "1.146 MPa"
q.Format(qty.DefaultFormatter) // 1.146 MPa => "1.146 MPa"

fn := func(scalar float64, unit string) string {
    v := number.Decimal(scalar, number.MaxIntegerDigits(4), number.MinIntegerDigits(2))
    return message.NewPrinter(language.Dutch).Sprintf("%v %v", v, unit)
}
f := q.Format(fn)               // 2.987654321 m => 02,988 m
----

.Temperature
qoqty makes a distinction between a temperature and degrees of a temperature.
Temperature units (eg tempC) can be converted back and forth, and will take into account the differences in the zero points of the various scales.  Differential temperature degree (eg degC) units behave like most other units.
It is an error to create a temperature below absolute zero.
Math with temperatures is fairly limited.
[source,go]
----
t100, _ := qty.Parse("100 tempC")
t100.Add("10 degC")             // 110 tempC; temp + deg is always safe 
t100.Sub("10 degC")             // 90 tempC;  temp - deg is always safe
t100.Add("50 tempC")            // error; can't add two temperatures
t100.Sub("50 tempC")            // 50 degC
t100.Sub("150 tempC")           // -50 degC
t100.Mul(2)                     // 200 tempC
t100.Div(2)                     // 50 tempC
t100.Inverse()                  // error
t100.Mul(qty)                   // error
t100.Div(qty)                   // error
qty.Parse("100 tempC*unit")     // error
qty.Parse("100 tempC/unit")     // error
qty.Parse("100 unit/tempC")     // error
t100.To("degC")                 // 100 degC; references the 0 point on the scale of the temperature unit

d100, _ := qty.Parse("100 degC")
d100.To("tempC")                // -173.15 tempC; interpreted as being relative to absolute zero
----

.Kinds and Units
[source,go]
----
k := qty.Kinds()            // a list of kinds of units (length, area, volume, time, ...)
u := qty.Units("length")    // a list of units of a kind (meter, inch, foot, mile, ...)
a := qty.Aliases("m")       // a list of unit aliases (m, meter, meters, metre, metres)
----


// `Qty.swiftConverter()` is a fast way to efficiently convert large array of
// Number values. It configures a function accepting a value or an array of Number
// values to convert.

// ```javascript
// var convert = Qty.swiftConverter('m/h', 'ft/s'); // Configures converter

// // Converting single value
// var converted = convert(2500); // => 2.278..

// // Converting large array of values
// var convertedSerie = convert([2500, 5000, ...]); // => [2.278.., 4.556.., ...]
// ```

// The main drawback of this conversion method is that it does not take care of
// rounding issues.


// ### Rounding

// `Qty#toPrec(precision)` : returns the nearest multiple of quantity passed as
// precision.

// ```javascript
// var qty = Qty('5.17 ft');
// qty.toPrec('ft'); // => 5 ft
// qty.toPrec('0.5 ft'); // => 5 ft
// qty.toPrec('0.25 ft'); // => 5.25 ft
// qty.toPrec('0.1 ft'); // => 5.2 ft
// qty.toPrec('0.05 ft'); // => 5.15 ft
// qty.toPrec('0.01 ft'); // => 5.17 ft
// qty.toPrec('0.00001 ft'); // => 5.17 ft
// qty.toPrec('2 ft'); // => 6 ft
// qty.toPrec('2'); // => 6 ft

// var qty = Qty('6.3782 m');
// qty.toPrec('dm'); // => 6.4 m
// qty.toPrec('cm'); // => 6.38 m
// qty.toPrec('mm'); // => 6.378 m
// qty.toPrec('5 cm'); // => 6.4 m
// qty.toPrec('10 m'); // => 10 m
// qty.toPrec(0.1); // => 6.3 m

// var qty = Qty('1.146 MPa');
// qty.toPrec('0.1 bar'); // => 1.15 MPa
// ```

// ### Formatting quantities

// `Qty#toString` returns a string using the canonical form of the quantity (that
// is it could be seamlessly reparsed by `Qty`).

// ```javascript
// var qty = Qty('1.146 MPa');
// qty.toString(); // => '1.146 MPa'
// ```

// As a shorthand, units could be passed to `Qty#toString` and is equivalent to
// successively call `Qty#to` then `Qty#toString`.

// ```javascript
// var qty = Qty('1.146 MPa');
// qty.toString('bar'); // => '11.46 bar'
// qty.to('bar').toString(); // => '11.46 bar'
// ```

// `Qty#toString` could also be used with any method from `Qty` to make some sort
// of formatting. For instance, one could use `Qty#toPrec` to fix the maximum
// number of decimals:

// ```javascript
// var qty = Qty('1.146 MPa');
// qty.toPrec(0.1).toString(); // => '1.1 MPa'
// qty.to('bar').toPrec(0.1).toString(); // => '11.5 bar'
// ```

// For advanced formatting needs as localization, specific rounding or any other
// custom customization, quantities can be transformed into strings through
// `Qty#format` according to optional target units and formatter. If target units
// are specified, the quantity is converted into them before formatting.

// Such a string is not intended to be reparsed to construct a new instance of
// `Qty` (unlike output of `Qty#toString`).

// If no formatter is specified, quantities are formatted according to default
// js-quantities' formatter and is equivalent to `Qty#toString`.

// ```javascript
// var qty = Qty('1.1234 m');
// qty.format(); // same units, default formatter => '1.234 m'
// qty.format('cm'); // converted to 'cm', default formatter => '123.45 cm'
// ```

// `Qty#format` could delegates formatting to a custom formatter if required. A
// formatter is a callback function accepting scalar and units as parameters and
// returning a formatted string representing the quantity.

// ```javascript
// var configurableRoundingFormatter = function(maxDecimals) {
//   return function(scalar, units) {
//     var pow = Math.pow(10, maxDecimals);
//     var rounded = Math.round(scalar * pow) / pow;

//     return rounded + ' ' + units;
//   };
// };

// var qty = Qty('1.1234 m');

// // same units, custom formatter => '1.12 m'
// qty.format(configurableRoundingFormatter(2));

// // convert to 'cm', custom formatter => '123.4 cm'
// qty.format('cm', configurableRoundingFormatter(1));
// ```

// Custom formatter can be configured globally by setting `Qty.formatter`.

// ```javascript
// Qty.formatter = configurableRoundingFormatter(2);
// var qty = Qty('1.1234 m');
// qty.format(); // same units, current default formatter => '1.12 m'
// ```

// ### Temperatures

// Like ruby-units, JS-quantities makes a distinction between a temperature (which
// technically is a property) and degrees of temperature (which temperatures are
// measured in).

// Temperature units (i.e., 'tempK') can be converted back and forth, and will take
// into account the differences in the zero points of the various scales.
// Differential temperature (e.g., '100 degC') units behave like most other units.

// ```javascript
// Qty('37 tempC').to('tempF') // => 98.6 tempF
// ```

// JS-quantities will throw an error if you attempt to create a temperature unit
// that would fall below absolute zero.

// Unit math on temperatures is fairly limited.

// ```javascript
// Qty('100 tempC').add('10 degC')  // 110 tempC
// Qty('100 tempC').sub('10 degC')  // 90 tempC
// Qty('100 tempC').add('50 tempC') // throws error
// Qty('100 tempC').sub('50 tempC') // 50 degC
// Qty('50 tempC').sub('100 tempC') // -50 degC
// Qty('100 tempC').mul(scalar)     // 100*scalar tempC
// Qty('100 tempC').div(scalar)     // 100/scalar tempC
// Qty('100 tempC').mul(qty)        // throws error
// Qty('100 tempC').div(qty)        // throws error
// Qty('100 tempC*unit')            // throws error
// Qty('100 tempC/unit')            // throws error
// Qty('100 unit/tempC')            // throws error
// Qty('100 tempC').inverse()       // throws error
// ```

// ```javascript
// Qty('100 tempC').to('degC') // => 100 degC
// ```

// This conversion references the 0 point on the scale of the temperature unit

// ```javascript
// Qty('100 degC').to('tempC') // => -173.15 tempC
// ```

// These conversions are always interpreted as being relative to absolute zero.
// Conversions are probably better done like this...

// ```javascript
// Qty('0 tempC').add('100 degC') // => 100 tempC
// ```

// ### Errors

// Every error thrown by JS-quantities is an instance of `Qty.Error`.

// ```javascript
// try {
//   // code triggering an error inside JS-quantities
// }
// catch(e) {
//   if(e instanceof Qty.Error) {
//     // ...
//   }
//   else {
//     // ...
//   }
// }
// ```

// ## Tests

// Tests are implemented with Jasmine (https://github.com/pivotal/jasmine).
// You could use both HTML and jasmine-node runners.

// To execute specs through HTML runner, just open `SpecRunner.html` file in a
// browser to execute them.

// To execute specs through `jasmine-node`, launch:

//     make test

// ### Performance regression test

// There is a small benchmarking HTML page to spot performance regression between
// currently checked-out quantities.js and any committed version.
// Just execute:

//     make bench

// then open http://0.0.0.0:3000/bench

// Checked-out version is benchmarked against HEAD by default but it could be changed by passing
// any commit SHA on the command line. Port (default 3000) is also configurable.

//     make bench COMMIT=e0c7fc468 PORT=5000

// ## TypeScript type declarations

// A TypeScript declaration file is published on
// [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/js-quantities).

// It could be installed with `npm install @types/js-quantities`.

// ## Contribute

// Feedback and contributions are welcomed.

// Pull requests must pass tests and linting. Please make sure that `make test`
// and `make lint` return no errors before submitting.